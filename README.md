# Устройство новой мапы в Go 1.24

status: В разработке

# Терминология

- Слот (Slot) - хранили пары ключ-значение
- Группа (Group) - Группа из 8-и слотов + контрольное слово
- Контрольное слово (Control word) - 8-ми байтное слово. Каждый байт которого представляет контрольный байт слота.
- Контрольный байт(Control byte) - 8-и битное число, которое состоит из 7 бит хэша и 1 бита заполненности, который говорит нам, о том, что слот заполнен, пуст или удалён.
- H1 - Старшие 57 бит хэша.
- H2 - Младшие 7 бит хэша.
- Таблица - Полная реализация хэш таблицы - "Swiss Table". Таблица состоит из одной или более групп для хранения слотов + метаданные для осуществления операций с таблицей и определения момента, когда необходимо расширять мапу.
- Мапа (Map) - Верхне-уровневый тип Map состоящий из одной или более таблиц.
  Старшие биты определяют, какой таблице принадлежит хэш.
- Хранилище(Directory) - Массив таблиц, используемых мапой (Map)

Картинки с устройством

Картинка с устройством контрольного байта слота.

Важно понимать, что каждый слот не содержит в себе контрольный байт, но связан с ним через контрольное слово.

# Квадратичный поиск (Quadratic probing)
О том, что такое квадратичный поиск можно почитать в той же [википедии](https://en.wikipedia.org/wiki/Quadratic_probing) Основная его суть (нам для понимания) - когда мы осуществляем поиск, вставку или удаление элемента из хэш таблицы - мы проходим не по всем таблицам, а только по тем, которые получили из функции квадратичного поиска:

`p(i) := (i^2 + i)/2 + hash (mod mask+1)`

Её реализацию можно посмотреть [тут](https://cs.opensource.google/go/go/+/release-branch.go1.24:src/internal/runtime/maps/table.go) -> probeSeq

Понимание квадратичного поиска нам понадобится в дальнейшем, когда мы будем разбирать, как осуществляется поиск, вставка и удаление в новой мапе.

Использование квадратичного поиска вводит нам важные ограничения - число групп должно быть степенью 2, последняя группа в квадратичном поиске должна быть пуста. (Таблица не может быть заполнена на 100%)

# SIMD инструкции

Эта технология используется для поиска слота по хэшу внутри группы. Основная её мощь в том, что теперь мы можем не перебирать каждый слот в группе, а применить операцию сравнения полученного хэша(H2) одновременно ко всем 8-и слотам группы за одну операцию.

Статья на [википедии](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data) про SIMD

# Как происходит сплит хэша

Представим, что мы получили hash:
```
h = 0xABCDEF1234
```

Преобразуем в двоичную форму
```
0xABCDEF1234 = 1010101111001101111011110001001000110100
```

```
H2 = 101010 (первые 7 бит)
H1 = 111001101111011110001001000110100 (оставшиеся 57 бит)
```
Можете поиграться в cmd/hash_split.go (получить довольно легко H1 и H2 c помощью побитового сдвига).
# Как работает алгоритм поиска, вставки, удаления

H1 - используется для поиска группы, H2 - для получения конкретного слота в группе.
## Поиск
- После того, как мы получили H1 - формируется квадратичная последовательность(probeSeq). Мы проходим по всем индексам групп, полученным из probeSeq (то есть мы проходим не по всем группам, а только по тем, что получили из probSeq) и сравниваем H2 со всеми контрольными байтами группы до тех пор пока не находим нужный или пустой слот.

- Если слот имеет статус Deleted(tomstone), он игнорируется, если найден пустой слот(Empty), это означает, что больше элементов в группе нет и поиск заканчивается.
- Если найден контрольный байт с таким же H2, то осуществляется процесс полного сравнения найденного ключа с переданным ключом.
- В случае успешного сравнения - возвращается соответствующее ключу значение.
- В случае провала, возвращается значение по умолчанию.

## Вставка
Алгоритм вставки идентичен алгоритму поиска, но с некоторыми дополнениями.
- В случае успешного сравнения H2, соответствующее ключу значение переписывается на новое.
- Если найден слот в статусе Delted(tombstone). Данный слот запомниается, как возможное место для вставки, но поиск продолжается, чтобы убедиться, что ключ отсутствует.
- Если найден слот в статусе Empty, то при наличии tombstone, мы записываем новое значение в слот tobstone, а при его отсутствии в слот со статусом Empty.
## Удаление


# Рассказываем про рост мапы


# Проблемы старой мапы

Before Go 1.24, maps worked like this:

- Buckets: Your keys were stored in `buckets` (groups of 8 entries).
    
- Overflow Chains: If a bucket filled up, new entries went into `overflow` buckets, linked like a chain.
    
- Tophash: Each entry had a tiny `tophash` (8 bits of the key’s hash) to skip non-matching keys quickly.
    

It worked, but it had some rough edges:

- Slow Lookups: Scanning overflow chains meant jumping around in memory (hello, cache misses!).
    
- Memory Bloat: Overflow buckets ate up extra space.
    
- Resizing Woes: Growing the map meant rehashing everything. Ouch.

# Сила новой мапы

# Источники

Исходники [мапы](https://cs.opensource.google/go/go/+/release-branch.go1.24:src/internal/runtime/maps/map.go)
Исходники квадратичного [поиска](https://cs.opensource.google/go/go/+/release-branch.go1.24:src/internal/runtime/maps/table.go)
Статья на [хабре](https://habr.com/ru/companies/simbirsoft/articles/899180/), на которую я в основном опирался, но тема квадратичного поиска и алгоритмов поиска раскрыты с ошибками.